---
description: Pipeline for processing Postfix logs
processors:
- append:
    description: Append pipeline trace tag if enabled
    field: tags
    value:
        - "pipeline: default"
    if: ctx.tags != null && ctx.tags.contains('pipeline_trace_enabled')
- set:
    field: ecs.version
    value: "8.11.0"
- rename:
    field: message
    target_field: event.original
- set:
    field: event.timezone
    value: "{{_tmp.tz_offset}}"
    if: "ctx._tmp?.tz_offset != null && ctx._tmp?.tz_offset != 'local'"
- grok:
    description: Extract syslog base and message
    field: event.original
    patterns:
      - '%{SYSLOG_BASE}%{PROCESS_INFO}%{SPACE}%{GREEDYDATA:message}'
    pattern_definitions:
      SYSLOG_BASE: '%{SYSLOGTIMESTAMP:_tmp.timestamp}%{SPACE}%{HOST}%{SPACE}'
      HOST: '(?:%{IP:host.ip}|%{HOSTNAME:host.name})'
      PROCESS_INFO: '((?<process.name>\w+)[\[:]+?(%{POSINT:process.pgid:long}\]:|)|(?<process.name>[\w\/-]+)\[%{POSINT:process.pid:long}\]:)?'
- date:
    description: Set event timestamp
    field: _tmp.timestamp
    formats:
        - MMM  d HH:mm:ss
        - MMM d HH:mm:ss
        - MMM dd HH:mm:ss
    target_field: '@timestamp'
    timezone: '{{ event.timezone }}'
    if: 'ctx.event?.timezone != null && ctx._tmp?.timestamp != null'
- set:
    description: Copy the process group parent ID to process ID if populated
    field: process.pid
    override: false
    ignore_empty_value: true
    copy_from: process.pgid
- grok:
      description: Set Event Provider
      field: process.name
      patterns:
        - '%{WORD:event.provider}/(?<event.module>[\w-]+)|(?<event.provider>[\w-]+)'
- set:
    description: 'Copy event.provider to event.module if event.module is empty'
    field: event.module
    value: "{{event.provider}}"
    if: ctx.event?.module == null
- pipeline:
    name: '{{ IngestPipeline "master" }}'
    if: ctx.event?.module == 'master'
- pipeline:
    name: '{{ IngestPipeline "anvil" }}'
    if: ctx.event?.module == 'anvil'
- pipeline:
    name: '{{ IngestPipeline "pickup" }}'
    if: ctx.event?.module == 'pickup'
- pipeline:
    name: '{{ IngestPipeline "postfix-script" }}'
    if: ctx.event?.module == 'postfix-script'
- pipeline:
    name: '{{ IngestPipeline "qmgr" }}'
    if: ctx.event?.module == 'qmgr'
- pipeline:
    name: '{{ IngestPipeline "cleanup" }}'
    if: ctx.event?.module == 'cleanup'
- pipeline:
    name: '{{ IngestPipeline "local" }}'
    if: ctx.event?.module == 'local'
- pipeline:
    name: '{{ IngestPipeline "opendkim" }}'
    if: ctx.event?.module == 'opendkim'
- pipeline:
    name: '{{ IngestPipeline "policyd-spf" }}'
    if: ctx.event?.module == 'policyd-spf'
- pipeline:
    name: '{{ IngestPipeline "smtpd" }}'
    if: ctx.event?.module == 'smtpd'
- pipeline:
    name: '{{ IngestPipeline "smtp" }}'
    if: ctx.event?.module == 'smtp'
- pipeline:
    name: '{{ IngestPipeline "scache" }}'
    if: ctx.event?.module == 'scache'
- pipeline:
    name: '{{ IngestPipeline "error" }}'
    if: ctx.event?.module == 'error'
- convert:
    field: client.address
    target_field: client.ip
    type: ip
    ignore_failure: true
    ignore_missing: true
- convert:
    field: server.address
    target_field: server.ip
    type: ip
    ignore_failure: true
    ignore_missing: true
- pipeline:
    name: '{{ IngestPipeline "geoip" }}'
    if: ctx.tags != null && ctx.tags.contains('geoip_enabled') && (ctx.server?.ip != null || ctx.client?.ip != null)
# ------------------------------------------------------------------------------------------------------------------
# Postfix error event processing
#   TODO: Should probably move this to it's own pipeline
# ------------------------------------------------------------------------------------------------------------------
- script:
    # TODO: Modify this to generate a shorter, more useable error.id.  Maybe a hash of the UUID?
    source: |
        def err = ctx.error;
        err.id = java.util.UUID.randomUUID().toString();
        ctx.error = err;
    if: 'ctx.error?.message != null'
    description: "Generate an UUID and assign it to error.id if the event contains an error message."
- lowercase:
    description: 'Drop error.code to lowercase if populated'
    field: error.code
    if: "ctx.error?.code != null"
# ---- End Section -----
- append:
    description: Append a catch_all tag to events that did not match a specific grok processor in any pipeline
    field: tags
    value: catch_all
    if: ctx._tmp?.catch_all != null || ctx._tmp?.defaulted_event != null
- remove:
    description: Remove _tmp fields
    field:
    - _tmp
    ignore_failure: true
- remove:
    description: Remove event.original if preserve_original_event is not set
    field: event.original
    if: "ctx.tags == null || !(ctx.tags.contains('preserve_original_event'))"
    ignore_failure: true
    ignore_missing: true
on_failure:
- set:
    field: event.kind
    value: pipeline_error
- join:
    field: _tmp.trace.pipeline
    separator: ' --> '
    description: 'Build pipeline tracing string'
- append:
    field: error.message
    value:
      - '{{{ _ingest.on_failure_message }}}'
      - 'Pipeline path: {{{_tmp.trace.pipeline}}}'
- remove:
    description: 'Remove _tmp fields'
    field:
      - _tmp
    ignore_failure: true

